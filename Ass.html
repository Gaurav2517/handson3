<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Backtracking</h1>
    <p>Backtracking is a form of recursion.</p><br>
    <p>The usual scenario is that you are faced with a number of options, and you must choose one of these. After you make your</p>
    <p>choice you will get a new set of options; just what set of options you get depends on what choice you made. This procedure is</p>
    <p>repeated over and over until you reach a final state. If you made a good sequence of choices, your final state is a goal state; if</p>
    <p>you didn't, it isn't.</p><br>
    <p>Conceptually, you start at the root of a tree; the tree probably has some good leaves and some bad leaves, though it may be that</p>
    <p>the leaves are all good or all bad. You want to get to a good leaf. At each node, beginning with the root, you choose one of its</p>
    <p>children to move to, and you keep this up until you get to a leaf.</p><br>
    <p>Suppose you get to a bad leaf. You can backtrack to continue the search for a good leaf by revoking your most recent choice,</p>
    <p>and trying out the next option in that set of options. If you run out of options, revoke the choice that got you here, and try</p>
    <p>another choice at that node. If you end up at the root with no options left, there are no good leaves to be found.</p><br>
    <p>This needs an example.</p>
    <img src="./Image_root.png" width="200" height="200">
    <ol>
    <li>Starting at Root, your options are A and B. You choose A.</li>
    <li>At A, your options are C and D. You choose C.</li>
    <li>C is bad. Go back to A.</li>
    <li>At A, you have already tried C, and it failed. Try D.</li>
    <li>D is bad. Go back to A.</li>
    <li>At A, you have no options left to try. Go back to Root.</l>
    <li>At Root, you have already tried A. Try B.</li>
    <li>At B, your options are E and F. Try E.</li>
    <li>E is good. Congratulations!</li>
    </ol>
    <p>In this example we drew a picture of a tree. The tree is an abstract model of the possible sequences of choices we could</p>
    <p>make. There is also a data structure called a tree, but usually we don't have a data structure to tell us what choices we</p>
    <p>have. (If we do have an actual tree data structure, backtracking on it is called depth-first tree searching.)</p><br>
    <h4>The backtracking algorithm</h4>
    <pre>
        <font color="blue"> boolean solve(Node n) {
            if n is a leaf node {
               if the leaf is a goal node, return true
               else return false 
            } else {
               for each child c of n {
                   if solve(c) succeeds, return true
               }
              return false
             } 
           }</font>
        </pre>
    <p>Notice that the algorithm is expressed as a boolean function. This is essential to understanding the algorithm. If</p>
    <p>solve(n) is true, that means node n is part of a solution--that is, node n is one of the nodes on a path from the root to</p>
    <p>some goal node. We say that n is solvable. If solve(n) is false, then there is no path that includes n to any goal node.</p><br>
    <h4>How does this work?</h4>
    <ul>
    <li>If any child of n is solvable, then n is solvable.</li>
    <li>If no child of n is solvable, then n is not solvable.</li>
    </ul>
    <br>
    <p>Hence, to decide whether any non-leaf node n is solvable (part of a path to a goal node), all you have to do is test whether any </p>
    <p>child of n is solvable. This is done recursively, on each child of n. In the above code, this is done by the lines</p>
    <pre>
        <font color="blue">
        for each child c of n {
           if solve(c) succeeds, return true
         } 
         return false
        </font>
        </pre>
    <p>Eventually the recursion will "bottom" out at a leaf node. If the leaf node is a goal node, it is solvable; if the leaf node is not a goal</p> 
    <p>node, it is not solvable. This is our base case. In the above code, this is done by the lines</p>
    <pre>
        <font color="blue">
        if n is a leaf node { 
          if the leaf is a goal node, return true
          else return false 
         }
        </font>
        </pre><br>
     <p>The backtracking algorithm is simple but important. You should understand it thoroughly. Another way of stating it is as follows:</p><br>    
     <ul>
       <li><b>To search a tree:</b></li>
    </ul<br>
    <ol>
     <li>If the tree consists of a single leaf, test whether it is a goal node.</li>
     <li>Otherwise, search the subtrees until you find one containing a goal node, or until you have</li>
     <p>searched them all unsuccessfully.</p>
    </ol>
     <h4>Non-recursive backtracking, using a stack</h4>
     <p>Backtracking is a rather typical recursive algorithm, and any recursive algorithm can be rewritten as a stack algorithm. In fact,</p>
     <p>that is how your recursive algorithms are translated into machine or assembly language.</p><br>
     <pre>
        <font color="blue">
            boolean solve(Node n) {
           put node n on the stack;
            while the stack is not empty {
             if the node at the top of the stack is a leaf {
              if it is a goal node, return true
               else pop it off the stack
            }
            else {
             if the node at the top of the stack has untried children
                 push the next untried child onto the stack 
                else pop the node off the stack


             }
             return false 
            }
        </font>
        </pre>
       <p>Starting from the root, the only nodes that can be pushed onto the stack are the children of the node currently on the top of the</p>
       <p>stack, and these are only pushed on one child at a time; hence, the nodes on the stack at all times describe a valid path in the</p> 
       <p>tree. Nodes are removed from the stack only when it is known that they have no goal nodes among their descendents. Therefore,</p>
       <p>if the root node gets removed (making the stack empty), there must have been no goal nodes at all, and no solution to the</p>
       <p>problem.</p><br>
       <p>When the stack algorithm terminates successfully, the nodes on the stack form (in reverse order) a path from the root to a goal</p>
       <p>node.</p><br>
       <p>Similarly, when the recursive algorithm finds a goal node, the path information is embodied (in reverse order) in the sequence of</p>
       <p>recursive calls. Thus as the recursion unwinds, the path can be recovered one node at a time, by (for instance) printing the node</p>
       <p>at the current level, or storing it in an array.</p><br>
       <p>Here is the recursive backtracking algorithm, modified slightly to print (in reverse order) the nodes along the successful path:</p>
       <pre>
        <font color="blue">
            boolean solve(Node n) {
             if n is a leaf node {
              if the leaf is a goal node {
               print n
                return true
             }
               else return false
             } else {
                 for each child c of n {
                   if solve(c) succeeds {
                     print n
                     return true
                  }
                 } 
                 return false
               }
            }</font>
        </pre>
        <h4>Keeping backtracking simple</h4>
        <p>All of these versions of the backtracking algorithm are pretty simple, but when applied to a real problem, they can get pretty</p>
        <p>up with details. Even determining whether the node is a leaf can be complex:</p><br>
        <p>for example, if the path represents a series of moves in a chess endgame problem, the leaves are the checkmate and stalemate</p>
        <p>solutions</p><br>
        <p>To keep the program clean, therefore, tests like this should be buried in methods. In a chess game, for example, you could test</p>
        <p>whether a node is a leaf by writing a<b> gameOver method</b> (or you could even call it <b>isLeaf).</b> This method would encapsulate all the</p>
        <p>ugly details of figuring out whether any possible moves remain.</p><br>
        <p>Notice that the backtracking altorithms require us to keep track, for each node on the current path, which of its children have</p>
        <p>been tried already (so we don't have to try them again). In the above code we made this look simple, by just saying<b> for each child</p>
        <p>c of n.</b> In reality, it may be difficult to figure out what the possible children are, and there may be no obvious way to step through</p>
        <p>them. In chess, for example, a node can represent one arrangement of pieces on a chessboard, and each child of that node can</p>
        <p>represent the arrangement after some piece has made a legal move. How do you find these children, and how do you keep track</p>
        <p>of which ones you've already examined?</p><br>
        <p>The most straightforward way to keep track of which children of the node have been tried is as follows: Upon initial entry to the</p>
        <p>node (that is, when you first get there from above), make a list of all its children. As you try each child, take it off the list. When</p>
        <p>the list is empty, there are no remaining untried children, and you can return "failure." This is a simple approach, but it may require</p><br>
        <p>quite a lot of additional work.</p><br>
        <p>There is an easier way to keep track of which children have been tried, if you can define an ordering on the children. If there is an</p>
        <p>ordering, and you know which child you just tried, you can determine which child to try next.</p><br>
        <p>For example, you might be able to number the <b>children 1 through n,</b> and try them in numerical order. Then, if you have just tried</p>
        <p><b>child k,</b> you know that you have already tried children 1 through<b> k-1,</b> and you have not yet tried children<b> k+1</b> through<b>n.</b>  Or, if you </p>
        <p>are trying to color a map with just four colors, you can always try<b> red first, then yellow, then green, then blue.</b> If child yellow fails,</p>
        <p>you know to try child green next. If you are searching a maze, you can try choices in the order left, straight, right<b> (or perhaps</p>
        <p>north, east, south, west).</b></p><br>
        <p>It isn't always easy to find a simple way to order the children of a node. <b>In the chess game example,</b> you might number your</p>
        <p>pieces (or perhaps the squares of the board) and try them in numerical order; but in addition each piece may also have several</p>
        <p>moves, and these must also be ordered.</p>
        <h4>Example: Tree Search</h4>
        <p>For starters, let's do the simplest possible example of backtracking, which is searching an actual tree. We will also use the</p>
        <p>simplest kind of tree, a binary tree.</p><br>
        <p>A binary tree is a data structure composed of nodes. One node is designated as the root node. Each node can reference (point </p>
        <p>to) zero, one, or two other nodes, which are called its children. The children are referred to as the left child and/or the right child.</p>
        <p>All nodes are reachable (by one or more steps) from the root node, and there are no cycles. For our purposes, although this is not</p>
        <p>part of the definition of a binary tree, we will say that a node might or might not be a goal node, and will contain its name. The</p>
        <p>first example in this paper (which we repeat here) shows a binary tree.</p><br>
        <p>Here's a definition of the BinaryTree class:</p>
        <pre>
            <font color="blue">
                public class BinaryTree {
               BinaryTree leftChild = null;
               BinaryTree rightChild = null; 
               boolean isGoalNode = false; 
               String name;<br>
              BinaryTree(String name, BinaryTree left, BinaryTree right, boolean isGoalNode) { 
                this.name = name; 
                leftChild = left; 
                rightChild = right; 
                this.isGoalNode = isGoalNode; 
                }
              }</font>
            </pre>
        <p>Next we will create a TreeSearch class, and in it we will define a method makeTree() which constructs the above binary tree.</p><br>
        <pre>
            <font color="blue">
                static BinaryTree makeTree() { 
               BinaryTree root, a, b, c, d, e, f; 
               c = new BinaryTree("C", null, null, false); 
               d = new BinaryTree("D", null, null, false); 
               e = new BinaryTree("E", null, null, true); 
               f = new BinaryTree("F", null, null, false); 
               a = new BinaryTree("A", c, d, false); 
               b = new BinaryTree("B", e, f, false); 
               root = new BinaryTree("Root", a, b, false); 
               return root; 
            }</font>
        </pre><br>
          <p>Here's a main program to create a binary tree and try to solve it:</p><br>
          <pre>
            <font color="blue">
                public static void main(String args[]) {
                 BinaryTree tree = makeTree(); 
                 System.out.println(solvable(tree)); 
               }</font>
            </pre>  <br>
            <p>And finally, here's the recursive backtracking routine to "solve" the binary tree by finding a goal node.</p><br>
            <pre>
                <font color="blue">
                    static boolean solvable(BinaryTree node) { 
                 /* 1 */ if (node == null) return false; 
                 /* 2 */ if (node.isGoalNode) return true; 
                 /* 3 */ if (solvable(node.leftChild)) return true; 
                 /* 4 */ if (solvable(node.rightChild)) return true; 
                 /* 5 */ return false; 
                 }</font>
                </pre><br>
            <p>Here's what the numbered lines are doing:</p>
            <ol>
            <li>If we are given a null node, it's not solvable. This statement is so that we can call this method with the children of a node, without</li>
            <p>first checking whether those children actually exist.</p>
            <li>If the node we are given is a goal node, return success.</li>
            <li>See if the left child of node is solvable, and if so, conclude that node is solvable. We will only get to this line if node is non-null </li>
            <p>and is not a goal node, says to</p>
            <li>Do the same thing for the right child.</li>
            <li>Since neither child of node is solvable, node itself is not solvable.</li>
            </ol>
            <br>
            <p>This program runs correctly and produces the unenlightening result true.</p><br>
            <p>Each time we ask for another node, we have to check if it is null. In the above we put that check as the first thing in solvable. An</p> 
             <p>alternative would be to check first whether each child exists, and recur only if they do. Here's that alternative version:</p><br>
               <pre>
                <font color="blue">
                    static boolean solvable(BinaryTree node) { 
                     if (node.isGoalNode) return true; 
                     if (node.leftChild != null && solvable(node.leftChild)) return true; 
                     if (node.rightChild != null && solvable(node.rightChild)) return true; 
                     return false; 
                    }
                </font></pre><br>
            <p>I think the first version is simpler, but the second version is slightly more efficient.</p><br>
            <h4>What are the children?</h4>
            <p>One of the things that simplifies the above binary tree search is that, at each choice point, you can ignore all the previous</p> 
            <p>choices. Previous choices don't give you any information about what you should do next; as far as you know, both the left and the</p> 
            <p>right child are possible solutions. In many problems, however, you may be able to eliminate children immediately, without</p> 
            <p>recursion.</p><br>
            <p>Consider, for example, the problem of four-coloring a map. It is a theorem of mathematics that any map on a plane, no matter</p> 
            <p>how convoluted the countries are, can be colored with at most four colors, so that no two countries that share a border are the</p> 
            <p>same color.</p><br>
            <p>To color a map, you choose a color for the first country, then a color for the second country, and so on, until all countries are</p>
            <p>colored.</p><br>
            <p>There are two ways to do this:</p>
            <ul type="disc">
            <li>Method 1. Try each of the four possible colors, and recur. When you run out of countries, check whether you are at a goal node.</li>
            <li>Method 2. Try only those colors that have not already been used for an adjacent country, and recur. If and when you run out of</li> 
            <p>countries, you have successfully colored the map.</p>
            </ul>
            <br>
            <p>Let's apply each of these two methods to the problem of coloring a checkerboard. This should be easily solvable; after all, a</p>
            <p>checkerboard only needs two colors.</p><br>

            <p><b>boolean mapIsOK()</b></p>
            <p>Used by method 1 to check (at a leaf node) whether the entire map is colored correctly.</p> 
            <p><b>boolean okToColor(int row, int column, int color)</b></p> 
            <p>Used by method 2 to check, at every node, whether there is an adjacent node already colored with the given color.</p> 
            <p><b>int[] nextRowAndColumn(int row, int column)</b> </p> 
            <p>Used by both methods to find the next "country" (actually, the row and column of the next square on the checkerboard).</p><br>
            <p>Here's the code for method 1:</p>
            <pre>
                <font color="blue">
                    boolean explore1(int row, int column, int color) {
                  if (row >= NUM_ROWS)return mapIsOK(); 
                  map[row][column] = color; 
                 for (int nextColor = RED; nextColor <= BLUE; nextColor++) { 
                    int[] next = nextRowAndColumn(row, column); 
                    if (explore1(next[0], next[1], nextColor)) return true; 
                 } 
                 return false; 
                }</font>
            
            </pre><br>
                <p>And here's the code for method 2:</p><br>
                <pre>
                    <font color="blue">
                    boolean explore2(int row, int column, int color) { 
                     if (row >= NUM_ROWS)return true; 
                     if (okToColor(row, column, color)) { 
                        map[row][column] = color; 
                        for (int nextColor = RED; nextColor <= BLUE; nextColor++) { 
                            int[] next = nextRowAndColumn(row, column); 
                            if (explore2(next[0], next[1], nextColor)) return true; 
                        } 
                    } 
                    return false; 
                    }</font>
                </pre><br>
            <p>Those appear pretty similar, and you might think they are equally good. However, the timing information suggests otherwise:</p>
<table border="1" align="center">
    <tr>
        <th > </th>
        <th>2 by 3 map</th>
        <th>3 by 3 map</th>
        <th >3 by 4 map</th>
        
    </tr>

    <tr>
        <th> Method 1: </th>
        <th>60 ms.</th>
        <th>940 ms.</th>
        <th>60530ms.(1 minute)</th>
        
    </tr>
    <tr>
        <th>Method 2:</th>
        <th>0ms.</th>
        <th>0 ms.</th>
        <th>0 ms</th>
         
    </tr>
</table>





            <p>The zeros in the above table indicate times too short to measure (less than 1 millisecond). Why this huge difference? Either of</p> 
            <p>these methods could have exponential growth. Eliminating a node automatically eliminates all of its descendents, and this will</p>
            <p>often prevent exponential growth. Conversely, by waiting to check until a leaf node is reached, exponential growth is practically</p>
            <p>guaranteed. If there is any way to eliminate children (reduce the set of choices), do so!</p><br>
            <h4>Debugging techniques</h4>
            <p>Often our first try at a program doesn't work, and we need to debug it. Debuggers are helpful, but sometimes we need to fall</p> 
            <p>back on inserting print statements. There are some simple tricks to making effective use of print statements. These tricks can be</p> 
            <p>applied to any program, but are especially useful when you are trying to debug recursive routines.</p><br>
            <h4>Trick #1: Indent when you print method entries and exits.</h4><br> 
            <p>Often, the best debugging technique is to print every method call and return (or at least the most important ones). You probably</p> 
            <p>want to print, for each method, what parameters it came in with, and what value it leaves with. However, if you just print a long</p> 
            <p>list of these, it's hard to match up method exits with their corresponding entries. Indenting to show the level of nesting can help.</p><br>
            <h4>Trick #2: Use specialized print methods for debugging.</h4><br>
            <p>Don't clutter up your actual code more than you must. Also, remember that code inserted for debugging purposes can itself</p> 
            <p>contain bugs, or (in the worst case) can affect the results, so be very careful with it.</p><br>
            <p>Here's our debugging code. For this trivial program, there's almost more debugging code than actual code, but in larger programs</p>
            <p>the proportions will be better.</p><br>
            <pre> <font color="blue">
                static String indent = "";
                
                static String name(BinaryTree node) { 
                    if (node == null) return null; 
                    else return node.name; 
                } 
                
                static void enter(BinaryTree node) { 
                    System.out.println(indent + "Entering solvable(" + name(node) + ")"); 
                    indent = indent + "| "; 
                } 
                
                static boolean yes(BinaryTree node) { 
                    indent = indent.substring(3); 
                    System.out.println(indent + "solvable(" + name(node) + ") returns true"); 
                    return true; 
                } 
                
                static boolean no(BinaryTree node) { 
                    indent = indent.substring(3); 
                    System.out.println(indent + "solvable(" + name(node) + ") returns false"); 
                    return false; 
                }</font>
            </pre><br>
            <p>To use this code, we modify solvable as follows:</p>
                <pre>
                    <font color="blue">
                    static boolean solvable(BinaryTree node) { 
                      enter(node); 
                      if (node == null) return no(node); 
                      if (node.isGoalNode) return yes(node); 
                      if (solvable(node.leftChild)) return yes(node); 
                      if (solvable(node.rightChild)) return yes(node); 
                      return no(node); 
                    }</font>
                </pre><br>
                
            <p>And we get these results:</p>
            <pre>Entering solvable(Root) 
                     | Entering solvable(A) 
                     | | Entering solvable(C) 
                     | | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | solvable(C) returns false 
                     | | Entering solvable(D) 
                     | | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | solvable(D) returns false 
                     | solvable(A) returns false 
                     | Entering solvable(B) 
                     | | Entering solvable(E) 
                     | | solvable(E) returns true 
                     | solvable(B) returns true solvable(Root) returns true 
                     true</pre>
                <h4>Trick #3: Never discard your debugging statements.</h4>
                <p>Writing debugging statements is programming, too. Often it's as much work to debug the debugging statements as it is to debug</p> 
                       <p> the actual program. Once your program is working, why throw this code away? </p><br>
                        
                       <p>Obviously, you don't want to print out all this debugging information from a program you are ready to submit (or to turn over to </p>
                       <p>your manager). You could comment out your debugging calls, but that can be a lot of work. What's more, in the above example,</p> 
                       <p>you would have to replace every return(yes(node)) with return(true), and every return(no(node)) with return false. With all these </p>
                       <p>changes, you might introduce new bugs into your program.</p><br> 
                        
                       <p>The simple solution is to make your debugging statements conditional. For example,</p><br>
                <pre>
                    <font color="blue">
                          static final boolean debugging = false; 
                            
                           static void enter(BinaryTree node) { 
                            if (debugging) { 
                                System.out.println(indent + "Entering solvable(" + name(node) + ")"); 
                                indent = indent + "| "; 
                              } 
                            } 
                            
                            static boolean yes(BinaryTree node) { 
                                if (debugging) { 
                                    indent = indent.substring(3); 
                                    System.out.println(indent + "solvable(" + name(node) + ") returns true"); 
                                  } 
                                  return true; 
                             } 
                                
                            static boolean no(BinaryTree node) { 
                                if (debugging) { indent = indent.substring(3); 
                                    System.out.println(indent + "solvable(" + name(node) + ") returns false"); 
                                } 
                                return false; 
                             }</font>
                </pre>
                <p>In industry, actual programs often have multiple flags to control different aspects of debugging. Don't worry too much about </p>
                   <p>making your code larger; modern compilers will notice that since the variable debugging is final, it can never be true, and the </p>
                    <p>controlled code will be discarded.</p><br>
                <h4>Trick #4: Create an Exception.</h4>
                <p>If an Exception is thrown, you can get information about just where it happened by sending it the message </p>
                 <p>printStackTrace(PrintStream). Since an Exception is an object like any other, you can create and throw your own Exceptions.</p> 
                  <p>However, Java programmers don't always realize that you can create an Exception without throwing it. For example, the following</p> 
                    <p>code</p><br>
                <pre><font color="blue">  new Exception("Checkpoint Charlie").printStackTrace(System.out);</font></pre><br>
                <p>will print out a message something like this, and the program will then continue normally. That is, the above code just acts like a </p>
                    <p>print statement.</p><br>
                     <pre>
                        <font color="blue">
                        java.lang.Exception: Checkpoint Charlie
                           at TreeSearch.solvable(TreeSearch.java:53) 
                           at TreeSearch.solvable(TreeSearch.java:57) 
                           at TreeSearch.main(TreeSearch.java:72) 
                           at __SHELL38.run(__SHELL38.java:16) 
                           at bluej.runtime.ExecServer.suspendExecution(Unknown Source)
                        </font>
                     </pre><br>
                <h4>Example: Cindy's Puzzle</h4><br>
                <p>I call the following puzzle "Cindy's puzzle" for historical reasons. You have some number n black marbles and the same number</p> 
                <p>of white marbles, and you have a playing board which consists simply of a line of 2n+1 spaces to put the marbles in. Start with the</p>
                <p>black marbles all at one end (say, the left), the white marbles all at the other end, and a free space in between.</p>
                <table border="1" align="center">
                    <tr>
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px"></td>
                        <td><img src="./Ball white.png" width="40px"></td>
                        <td><img src="./Ball white.png" width="40px"></td>
                    </tr>
                   
            </table>
            <p>The goal is to reverse the positions of the marbles:</p>
            <table border="1" align="center">
                <tr>
                    <td><img src="./Ball white.png" width="40px"></td>
                    <td><img src="./Ball white.png" width="40px"></td>
                    <td width="40px"></td>
                    <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                    <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                </tr>
               
        </table>

            <p><b>The black marbles can only move to the right, and the white marbles can only move to the left (no backing up). At each move, a </p>
            <p>marble can either:</b></p><br>
            <ul type="disc">
                <li>Move one space ahead, if that space is clear, or</li>
                <li>Jump ahead over exactly one marble of the opposite color, if the space just beyond that marble is clear.</li>
            </ul>
            <p>For example, you could make the following sequence of moves:</p>
        <table border="1" align="center"  >
            <tr >
        
            <td ><b>Starting point:</b>  </td>
           
          
                    
                        <td ><img src="./Screenshot 2023-01-12 111951.png" width="40px" ></td>
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px" ></td>
                        <td width="40px">&nbsp; </td>
                        <td><img src="./Ball white.png" width="40px" ></td>
                        <td ><img src="./Ball white.png" width="40px" ></td>
                   
                  
            
        </tr><br>
    
        <tr>
            <td><b>Black moves ahead:</b></td>
           
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px">&nbsp;</td>
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td><img src="./Ball white.png" width="40px"></td>
                        <td><img src="./Ball white.png" width="40px"></td>
                  
               
            
          
        </tr><br>

        <tr>
            <td><b>White jumps:</b></td>
            
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td><img src="./Ball white.png" width="40px"></td>
                        <td><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px">&nbsp;</td>
                        <td><img src="./Ball white.png" width="40px"></td>
                
        </tr><br>

    
        <tr>
            <td><b>Black moves ahead:</b></td>
            
                        <td width="40px"><img src="./Screenshot 2023-01-12 111951.png"width="40px"></td>
                        <td width="40px"><img src="./Ball white.png"width="40px"></td>
                        <td width="40px">&nbsp;</td>
                        <td width="40px"><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px"><img src="./Ball white.png" width="40px"></td>
                   
        </tr><br>
    
        <tr>
           <td><b>Black jumps:</b></td>
                        <td width="40px">&nbsp;</td>
                        <td width="40px"><img src="./Ball white.png" width="40px"></td>
                        <td width="40px"><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px"><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px"><img src="./Ball white.png" width="40px"></td>
                        
                
        </tr><br>
    
        <tr>
           <td><b>White moves ahead:</b></td>
          
                        <td width="40px">&nbsp;</td>
                        <td width="40px"><img src="./Ball white.png" width="40px"></td>
                        <td width="40px"><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px"><img src="./Screenshot 2023-01-12 111951.png" width="40px"></td>
                        <td width="40px"><img src="./Ball white.png" width="40px"></td>
                        
                  
             </tr><br>
         <td><b>stucks!</b></td>
   
            </table><br><br>
        
<p>The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf,</p>
<p>which in this case means a position from which no further moves are possible. This isn't so easy.</p><br>
<p>Now to the program. The main program will initialize the board, and call a recursive backtracking routine to attempt to solve the</p> 
<p>puzzle. The backtracking routine will either succeed and print out a winning path, or it will fail, and the main program will have to</p><br>
 <p>print out the bad news.</p><br>
 <p>The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf,</p>
 <p>which in this case means a position from which no further moves are possible. This isn't so easy.</p><br>
 <p>Each possible move will result in a new board position, and these new board positions are the children of the current board</p>
 <p>position. Hence to find the children of a node (that is, of a board position), we need only find the possible moves from that node.</p>
 <p>Remember that it is also highly desirable to find an ordering on these possible moves.</p><br>
 <p>Here it is time to stop and take thought. To make progress, we must analyze the game to some extent. Probably a number of</p>
 <p>approaches would work, and what follows is based on the way I worked it out. If you were to program this puzzle, you might find </p>
 <p>a different but equally valid approach.</p><br>
 <p>First, notice that if a marble has a move, that move is unique: if it can move ahead one square, then it cannot jump. If it can jump,</p>
 <p>it cannot move ahead one square. This suggests that, to find the possible moves, we might assign numbers to the marbles, and</p>
 <p>check each marble in turn. When we have looked at all the marbles, we have looked at all the possible moves. This would require</p>
 <p>having a table to keep track of where each marble is, or else somehow "marking" each marble with its number and searching the</p>
 <p>board each time to find the marble we want. Neither alternative is very attractive.</p><br>
 <p>Next, notice that for a given board position, each marble occupies a unique space. Hence, instead of talking about moving a</p>
 <p>particular marble, we can talk about moving the marble in a particular space. If a move is possible from a given space, then that</p>
 <p>must be the only move possible from that space, because if the marble in that space has a move, it is unique. There is a slight</p>
 <p>complication because not every space contains a marble, but at least the spaces (unlike the marbles) stay in one place.</p><br>
<b>
<p>Now we have a simpler ordering of moves to use in our program. Just check, in order, the 2n+1 spaces of the board. For each</p>
    <p>space, either zero or one moves is possible. With this understanding, we can write a boolean method canMove(int[] board, int </p>
   <p>position) which determines whether a move is possible from the given position:</p></b>
   <ul type="disc">
    <li>If the position is empty, no move is possible;</li>
<li>If the position contains a black marble, the method checks for a move or jump to the right;</li>
 <li>If the position contains a white marble, the method checks for a move or jump to the left.</li><br>

 <p>We write another method <b>int[] makeMove(int[] oldBoard, int position) </b> will take a board and a position, make a move from</p> 
 <p>that position, and return as its value a new board. (We could write this somewhat more efficiently by changing the old board,</p>
 <p>rather than creating a new one, but here we are more concerned with simplicity.) In technical jargon, makeMove is "applicative"</p>
 <p>rather than "mutative."</p><br>
 <p>Along with<b>canMove and makeMove,</b> we are using methods<b>puzzleSolved and printBoard</b> with meanings that</p>
 <p>should be obvious.</p><br>
 <pre>
    <font color="blue">
    boolean solvable(int[] board) { 
        if (puzzleSolved(board)) {
          return true; 
        } 
        for (int position = 0; position  BOARD_SIZE; position++) {
          if (canMove(board, position)) { 
            int[] newBoard = makeMove(board, position);
             if (solvable(newBoard)) { 
                printBoard(newBoard);
                 return true;
                 }
             }
        }
         return false;
     }
    </font>
 </pre>
 <p>Along with canMove and makeMove, we are using methods puzzleSolved and printBoard with meanings that should be obvious.</p><br>
 <p>Here is some output from the program:</p>

  
    
  <pre> 
        <i><font color="blue">16.</font></i><strong> WHITE WHITE WHITE ____ BLACK BLACK BLACK</strong>
        <i><font color="blue">15.</font></i><b> WHITE WHITE WHITE BLACK ____ BLACK BLACK</b>
        <i><font color="blue">14.</font></i><b> WHITE WHITE BLACK _____ WHITE BLACK BLACK</b>
        <i><font color="blue">13.</font></i><b> WHITE _____ WHITE BLACK WHITE BLACK BLACK</b>
        <i><font color="blue">12.</font></i><b> WHITE BLACK WHITE _____ WHITE BLACK BLACK</b>
        <i><font color="blue">11.</font></i><b> WHITE BLACK WHITE BLACK WHITE _____ BLACK</b>
        <i><font color="blue">10.</font></i><b> WHITE BLACK WHITE BLACK WHITE BLACK _____</b>
        <i><font color="blue">9.</font></i><b> WHITE BLACK  WHITE BLACK _____BLACK WHITE</b>
        <i><font color="blue">8.</font></i><b> WHITE BLACK WHITE BLACK WHITE BLACK WHITE</b>
        <i><font color="blue">7.</font></i><b> _____ BLACK WHITE BLACK WHITE BLACK WHITE</b>
        <i><font color="blue">6.</font></i><b> BLACK _____ WHITE BLACK  WHITE BLACK WHITE</b>
        <i><font color="blue">5.</font></i><b> BLACK BLACK WHITE _____  WHITE BLACK WHITE</b>
        <i><font color="blue">4.</font></i><b> BLACK BLACK WHITE  BLACK WHITE BLACK WHITE</b>
        <i><font color="blue">3.</font></i><b> BLACK BLACK WHITE BLACK  _____  WHITE WHITE</b>
        <i><font color="blue">2.</font></i><b> BLACK BLACK _____ BLACK  WHITE WHITE WHITE</b>
        <i><font color="blue">1.</font></i><b> BLACK BLACK BLACK _____ WHITE  WHITE WHITE</b>
    </pre>

        

 
 
 
 
 <p>Notice that the solution is given in reverse order: BLACK starts out on the left and WHITE on the right, as in the last</p>
 <p>line. I've added line numbers to the actual output in order to emphasize this point. Backtracking always produces its</p>
 <p>results (sequence of choices) in reverse order; it is up to you, the programmer, to reverse the results again to get</p>
 <p>them in the correct order.</p>


</body>
</html>